#!/usr/bin/env ruby
=begin

TESTR 1 "2012-01-16" "14.2.0"
=============================

NAME
----

testr - Continuous testing tool for Ruby

SYNOPSIS
--------

`testr` [*OPTION*]... [*CONFIG*]...

DESCRIPTION
-----------

This program is a simple command-line user interface for testr-driver(1).  It
loads the given *CONFIG* files (which are either paths to actual files or
names of helper libraries in the testr/config/ namespace of Ruby's load path)
and then waits for you to supply interactive commands on its stdin.  You may
press the ENTER key (supplying no command) to see a menu of accepted commands.

OPTIONS
-------

`-h`, `--help`
  Display this help manual using man(1).

SEE ALSO
--------

testr(1), testr-driver(1), testr-master(1), testr-herald(1)

=end =========================================================================

$0 = File.basename(__FILE__) # for easier indentification in ps(1) output

require 'binman'
BinMan.help

require 'json'
ENV['TESTR_CONFIGS'] = JSON.dump(ARGV)

#-----------------------------------------------------------------------------
# backend
#-----------------------------------------------------------------------------

require 'testr/client'

warn 'testr: Absorbing test execution overhead...'
@driver = TestR::Client::Transceiver.new('testr-driver') do |line|
  evstr, *details = JSON.load(line)
  event = evstr.to_sym

  case event
  when :load then warn 'testr: Overhead absorbed. Ready for testing!'
  when :over then warn 'testr: Reabsorbing changed overhead files...'
  else
    test_file, test_names, *details = details
    message = [evstr.upcase, test_file, test_names.inspect, details].join(' ')

    color = case event
            when :pass then "\e[34m%s\e[0m" # blue
            when :fail then "\e[31m%s\e[0m" # red
            end
    message = color % message if color and STDOUT.tty?
    message = [message, File.read(test_file + '.log'), message] if event == :fail

    puts message
  end
end

#-----------------------------------------------------------------------------
# frontend
#-----------------------------------------------------------------------------

COMMANDS = {
  'r' => :run_all_test_files,
  's' => :stop_running_test_files,
  'p' => :rerun_passed_test_files,
  'f' => :rerun_failed_test_files,
  'o' => :reabsorb_overhead_files,
  'q' => :quit,
}

begin
  while key = STDIN.gets.chomp
    if command = COMMANDS[key]
      @driver.send [command]
      break if command == :quit
    else # invalid command
      COMMANDS.each do |key, command|
        warn "testr: Type #{key} then ENTER to #{command.to_s.tr('_', ' ')}."
      end
    end
  end
rescue Interrupt
  # forced quit
end

Process.waitall
